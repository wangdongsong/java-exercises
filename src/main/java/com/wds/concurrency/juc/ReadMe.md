#BlockQueue

##Queue（队列）
用于保存一组元素，不过在存取元素的时候必须遵循先进先出原则。队列是一种特殊的线性表，它只允许在表的前端进行删除，而在表的  
后端进行插入操作，进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。在队列这种数据结构中，
最先插入的元素将是最先被删除的元素，反之最后插入的元素将是最后被删除的元素，因此队列又为“先进行出”（FIFO-first in frist
out）线性表。

##Deque（双端队列）
两端都可以进出的队列。当我们约定从队列的一端进出队时，就形成了另外一种存取模式，它遵循先进后出原则，这就是栈结构。双端队
列主要是用于栈操作。使用栈结构让操作有可追溯性。

###数组阻塞队列ArrayBlockingQueue
ArrayBlockingQueue是一个由数组支持的有界的阻塞队列。此队列按FIFO（先进先出）原则对元素进行排序。队列的**头部**是在队列中
存在时间最长的元素。队列的**尾部**是在队列中存在时间最短的元素。新元素插入到队列的发问，队列获取操作则是从队列头部开始获
得元素。

这是一个典型的“有界缓冲区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓冲区，就不能
再增加其容易。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。

此类支持对等待的生产者线程和使用者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性（Fairness）
设置为true而构造的队列允许按照FIFO顺序访问线程。公平性通常会降低吞吐量，但也减少可变性和避免了“不平衡性”。

###链表阻塞队列LinkedBlockingDeque
LinkedBlockingDeque是基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也是维持一个数据缓冲队列（该队列由一个链表组成），
当生产者往队列放入一个数据时，队列会从生产者中获取数据，并缓存在队列内部，而生产者立即返回。只有当队列缓冲区达到最大值缓存
容量时，才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被。同理，消费者在处理数据是也是类似。

###优先级阻塞队列PriorityBlockingQueue
PriorityBlockingQueue是一个支持优先级排序的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但注意的是
PriorityBlockingQueue并会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此要注意，生产者生产数据的速度绝
对不能快于消费者的速度，否则时间一长，会最终耗尽所有可用的堆内容空间。在实现PriorityBlockingQueue时，内部按揭线程的锁采用
的是公平锁。

###延时队列DelayQueue
DelayQueue是一个支持延时获取元素的使用优先级队列的实现的无界阻塞队列。队列中的元素必须实现Delayed和Comparable接口，也就是说
DelayQueue里面的元素必须有compareTo和getDelay(TimeUnit unit)方法存在，在创建元素时可以指定多久才能从队列中获取当前元素。只有在
延迟期满时才能从队列中提取元素。DelayQueue的场景：

> * 缓存系统设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素，则缓存
有效期结束。
> * 定时任务调度：使用DelayQueue保存当天将执行的任务和执行时间，一旦从DelayQueue中获取到任务就执行。


###同步队列SynchronousQueue
SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成一个
传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身不存储元素。SynchronousQueue比LinkedBlockingDeque和ArrayBlockingQueue
的吞吐量大。
