##ReadWriteLock
###特性
> * 公平性<br>
    非公平锁（默认）。这个和独占锁的非公平性一样，由于读线程之间没有锁单键，所以读操作没有公平性和非公平性，写操作时，由于写操作  
    可能立即获取到锁，所以会推迟一个或多个读操作或者写操作。因此非公平锁的吞吐量要高于公平锁。公平锁利用AQS的CLH队列，释放当前保持的锁（读锁或写锁）时，
    优先为等待时间最长的那个写线程分配写入锁，当前前提是写线程的等待时间要比所有读线程的等待时间 要长。同样一个线程持有写入锁或者有一个写线程已经在等待了，
    那么试图获取公平锁的（非重入）所有线程（包括读写线程）都将被阻塞，直到最先的写线程释放锁。如果读线程的等待时间比写线程的等待时间还要长，那么一旦上一个
    线程释放锁，这一组读线程将获取锁。
> * 重入性<br>
    读写锁允许读线程和写线程按照请求锁的顺序重新获取读取锁或写入锁。当然了，只有写线程释放了锁，读线程才能获取重入锁。写线程获取写入锁后可以再次获取读取锁，
    但是读线程获取读取锁后却不能获取写入锁。另外读写锁最多支持65535个递归写入锁和65535个递归读取锁。
> * 锁降级：写线程获取写入锁后可以获取读取锁，然后释放写入锁，这样就从写入锁变成了读取锁，从而实现锁降级的特性。
> * 锁升级：读取锁是不能直接升级为写入锁的。因为获取一个写入锁需要释放所有读取锁，所以如果有两个读取锁试图获取写入锁，且都不释放读取锁时就会发生死锁。
> * 锁获取中断：读取锁和写入锁都支持获取锁期间被中断。这个和独占锁一致。
> * 条件变量：写入锁提供了条件变量的支持，这个和独占锁一致，但是读取锁却不允许获取条件变量，否则会得到一个UnsupportedOperationException异常。
> * 重入数：读取锁和写入锁的数量最大分别只能是65535

###读写锁机制
> * 读一读不互斥
> * 读-写互斥
> * 写-写互斥